{help_Types=
"\nPORTHOS recognizes eight Types, named 'QE', 'AB', 'MU', 'NU', 'XW', 'DW',"
"\n'SF', 'FS',  by their Pari-GP types and shape, and provides"
"\nfunctions 'is_QE' etc to test whether a given GEN is of the specified"
"\nType. The function 'Type(u)' applies those tests in the given order"
"\nand returns the string-value name of the first match, or if none of the" 
"\neight Types is recognized, simply returns Pari/GP's 'type(u)'."
"\nThe shapes admit an ambiguity: a 2x2 or 2x3 matrix satisfies 'is_XW'" 
"\nas well as 'is_FS'. 'Type' will in that case return 'XW'."
"\nType QE:  Two-term recursion coefficients; Stieltjes continued fraction."
"\n     [Q,E,mu0].  Q and E are vectors; length(Q)-length(E) is 0 or 1."
"\nType AB:  Three-term recursion coefficients; Jacobi continued fraction."
"\n     [A,B].  A and B are vectors; length(B)-length(A) is 0 or 1."
"\nType MU:  General modified moments."
"\n     [nu,Z]. nu contains baseless moments, Z is the basis," 
"\n     specified by an object that can be converted to type QE."
"\nType NU:  Baseless modified moments, especially Chebyshev moments."
"\n     [nu0,nu_1,...,nu_m]."  
"\nType XW:  Nodes and weights of a quadrature formula or nested family"
"\n     [x1,w1; x2,w2; ...;xn,wn] or [x1,w1,W1; x2,w2,W2; ...; xn,wn,Wn]."
"\n  In the second case, the weights W1..Wn usually give higher degree."
"\nType DW:  Gaps and weights of a quadrature formula"
"\n     [x0,dw], where dw has the same structure as Type XW"
"\nType SF: Stieltjies function."
"\n     p/q where p is a polynomial of degree one less that that of q."
"\nType FS: Factorial series."
"\n     [x1,x2,x3,...,xn; w1,w2,...,wn]"
;}

{bugs=
"\n  Three-term support is incomplete.  In particular, Gragg-Harrod has"
"\nnot been implemented: the technique is to convert to"
"\ntwo-term coefficients first.  This is unreliable and often may not work."
"\n  Some routines (mainly those depending on stqd) may give zero divisors"
"\nin a situation where the use of pu_qe would have avoided them.";}
{help_stieltjes_function=
"\nLet L be a linear functional defined on P_m, the space of polynomials of" 
"\ndegree <= m.  In practice, L is the restriction to P_m of a functional"
"\ndefined for more general functions."
"\nThe Stieltjes function R associated with L is a rational function with"
"\nnumerator of degree n-1 and denominator of degree n, where n=floor(m/2)."
"\nR(x) is formally obtained by expanding 1/(x-t) as a power series in t,"
"\ndiscarding the O(t^(m+1)) terms, and applying L.  PORTHOS manipulates"
"\nrepresentations of the Stieltjes function in terms of m+1 real numbers"  
"\nnamed QE, AB, XW, DW, and MU, see help(.  R(x) is evaluated by "
"\n'SF(u,x)', where u is of Type AB, QE or XW.";}
{help_qe_ab_xw_dw=
"\nThe Stieltjes function can be written as a continued fraction in two"
"\nstandard ways:"
"\n    R(z) = mu_0/(z- q[1]/(1- e[1]/(z- ... e[n-1]/(z-q[n])...)"
"\n         = b[1]/(z-a[1]- b[2]/(z-a[2]- ... b[n]/(z-a[n])...)"
"\ncorresponding respectively to the two-term and three-term recursion"
"\nformulas for the orthogonal polynomials.  These are:"
"\n               e_0 = 0, e_k=e[k], q_k=q[k],"
"\n            u_0(x) = 1,    p_0(x) = 1,"
"\n        u_{k+1}(x) = x p_k(x) - e_k u_k(x),"
"\n        p_{k+1}(x) = u_{k+1}(x) - q_{k+1} p_k(x),"
"\nand"
"\n               b_0 = mu_0, a_k=a[k+1], b_k=b[k+1],"
"\n         p_{-1}(x) = 0,    p_0(x) = 1,"
"\n        p_{k+1}(x) = (x-a_k)p_(x) - b_k."
"\nThe polynomials p_k and u_k are respectively called the 'orthogonal'"
"\nand 'auxiliary' polynomials with respect to L."
"\nWhen m is odd, the Stieltjes function can be written as a partial fraction:"
"\n    R(z) = w[1]/(x-x[1]) + w[n]/(x-x[n]) + ... + w[n]/(x-x[n])" 
"\nwhere the vectors x and w are respectively the nodes and weights"
"\nof the Gaussian quadrature formula for the functional L.  The symbol 'xw'"
"\ndenotes the pair [x,w], where x and w are vectors of length n."
"\nFor reasons of numerical stability, it is better to represent the"
"\ninformation contained in xw as the pair dw=[d,w] of gaps and weights,"
"\nwhere d[1]=x[1] and d[k]=x[k]-x[k-1] for k>1.";} 
{help_pseudo_constructor=
"\nFunctions AB(), QE(), XW() and DW() have similar argument lists."
"\nRemember that Pari/GP supplies 0 for the arguments that you omit."
"\n*  AB(n) and AB(\"Legendre\",n) mean the same as AB(\"Jacobi\",n)."
"\n*  AB(\"Gegenbauer\",nu) means the same as  AB(\"Jacobi\",n,nu=1/2,nu-1/2)."
"\n*  AB(\"Jacobi\",m,alf,bet) give AB coefficients for the Jacobi polynomials"
"\n   with the specified parameters over P_m.  m may be even or odd."
"\n*  AB(ab,m) restricts the given AB coefficients to P_m."
"\n*  AB(qe), AB(xw), or AB(dw) converts the given representation to Type AB."
"\n*  AB(mu,ab) calculates AB, given the modified moments mu of the"
"\n   polynomials generated by ab."
"\nIn functions XW and DW, the numeric parameter m means number of points,"
"\n   not degree of polynomial space.  E.g. XW(xw,4) keeps the first four"
"\n   points and weights." 
"\nFunction MU() is different."
"\n*  MU(u,r) calculates modified moments of the polynomials generated by r"
"\n   relative to the weight defined by u."
}
{help_modified_moments=
"\nThe modified moments of L with respect to another system given in terms of"
"\nrecursion coefficients QE are mu_k=L[P_k(@)], where P_k is the k-th"
"\nmonic polynomial generated by QE." 
"\nAn orthogonal expansion has the form"
"\n  c_0 p_0(x) + c_1 p_1(x) + ... + c_n p_n(x)"
"\nAn orthogonal expansion can be:"
"\n   evaluated at x=t:    o_eval(c,ab,t)" 
"\n   multiplied by x:     o_mulx(c,ab)"
"\n   dotted with another: o_dot(c1,c2,ab)"
"\nThere is a simple relationship between the modified moments of a weight"
"\nfunction w and the coefficients in the orthogonal expansion of w (exercise"
"\nfor the reader)."}
{help_left_endpoint=
"\nJust as an interval symmetric around 0 is natural for three-term recursion,"
"\nthe natural setting for two-term recursion is when the interval of support"
"\nof L has left endpoint 0.  This ensures that all recursion coefficients"
"\nare positive, that the qd algorithm used in the computations is"
"\numerically stable in a very strong sense, and that breakdown cannot"
"\noccur.  The routines will still work when the interval of support has"
"\nendpoint >0, but there is a possibility of precision loss.  They  might"
"\neven work when the interval of support of L contains 0 in its interior,"
"\nbut there is a possibility of breakdown besides a strong possibility"
"\nof precision loss."  
"\n  If some of the q or e coefficients are non-positive, the root finder"
"\nwill by default abort with an error message.  It can be forced to continue"
"\nregardless by setting 'FOOLHARDY=1'.";}
{help_exact_numeric=
"\nAs is usual in Pari/GP, all calculations are exact unless an operand in"
"\nfloating-point form is present, in which case the result is also in"
"\nfloating-point form.  For example, you can get the recursion coefficients"
"\nfor the Legendre polynomials by 'AB(n)' as rational numbers, or by" 
"\n'AB(n)*1.' as floating-point numbers."
"\nNB: The evaluation of a transcendental function always gives floating-point,"
"\n    even when the result is exact, e.g. exp(0) and log(1).\n"
"\nMany routines still work correctly given symbolic arguments."}
{help_globals=
  "\nPORTHOS_VERSION: The version number times 100. Nothing stops you from" 
  "\n   changing it in your calling program, but please don't do so. The idea"
  "\n   is that your routines can test whether the version is recent enough."
  "\nFOOLHARDY: Force the software to continue even when being abused."
  "\n   This variable is 0 (OFF) by default."
  "\nNORMALIZED: Normalize all weight functions so that L[1]=1.  Otherwise,"
  "\n   use the classical standardization and keep track of the value of L[1]"
  "\n   during transformations.  This variable is 0 (OFF) by default." 
  "\nWARN_NONPOSITIVE: Issue a warning when non-positive values appear in"
  "\n   a quantity of Type QE.  This variable is 1 (ON) by default."
  "\nWARN_SHIFT: Issue a warning when the shift overshoots.  The amount of"
  "\n   the shift, and the factor by which it overshoots, is printed."
  "\n   This variable is 0 (OFF) by default."
  "\nDEBUG: Issue an error message when a variable does not have a valid"
  "\n   shape for its Type"
}
{help_function_list=
  "  Type '?functionname' for more information about the function.\n" 
  "\n==Create two-term coefficients==> QE"
  "\n==Create three-term coefficients==> AB"
  "\n==Calculate gaps and weights==> DW"
  "\n==Calculate quadrature formula==> XW"
  "\n==Calculate modified moments==> MU"
  "\n==Evaluate Stieltjes function==> SF"
  "\n==Evaluate orthogonal polynomials==> o_pol"
  "\n==Manipulate orthogonal series==> o_ser o_mulx o_dot"
  "\n==Shift to another interval==> Shift"
  "\n==Modify two-term coefficients==> qe_anti qe_radau qe_lobatto qe_antigauss"
  "\n==Kronrod and stratified==> ab_kronrod ab_radkron vqe_stratify vxw_vqe"
  "\n==Apply quadrature formula==> integrate stratified_integrate"
  "\n==Combine formulas==> xw_combine"
  "\n==Utilities==> degree drop fac reverse take exactness Dimension Take Type Check "
  "\n  Type 'obscure_functions()' to see more.";}
{obscure_functions()=print(
  "\n  Type '?functionname' for more information about the function." 
  "\n==Intermediate routines==> "
  "\n  qe_ab qe_xw qe_dw qe_mu qe_r qe_shift qe_jacobi qe_laguerre"
  "\n  ab_radau ab_shift ab_wmul1 ab_wdiv1 ab_qe ab_xw ab_dw ab_refinable "
  "\n  dw_qe dw_xw dw_ab dw_shift " 
  "\n  xw_dw xw_qe xw_ab xw_shift "
  "\n  r_qe r_ab r_xw "
  "\n  pu_qe p_ab" 
  "\n  mu_qe mu_ab" 
  "\n==Low-level routines==> prqd prql prqr stqd stqd_symb"
  "\n  gaps poles qdshift weight qlpoles check_length findpolynomial ");} 
{help_menu=
  "\nPORTHOS is a Pari/GP package for working with orthogonal polynomials,"
  "\nGaussian quadrature, etc.\n"
  "\nhelp(1): Classified list of functions"
  "\nhelp(2): Types"
  "\nhelp(3): Pseudo-constructors"
  "\nhelp(4): Stieltjes function"
  "\nhelp(5): Recursion coefficients, nodes, gaps and weights"
  "\nhelp(6): Orthogonal expansions and modified moments"
  "\nhelp(7): Left endpoint zero"
  "\nhelp(8): Exact vs numerical calculations"
  "\nhelp(9): Global variables";}
{help(n)= 
  if(n==0, print(help_menu));
  if(n==1, print(help_function_list));
  if(n==2, print(help_Types));
  if(n==3, print(help_pseudo_constructor));
  if(n==4, print(help_stieltjes_function));
  if(n==5, print(help_qe_ab_xw_dw));
  if(n==6, print(help_modified_moments));
  if(n==7, print(help_left_endpoint));
  if(n==8, print(help_exact_numeric));
  if(n==9, print(help_globals))}
\\ Help information
addhelp(WARN_SHIFT, "See help(8)");
addhelp(WARN_ROUNDOFF, "See help(8)");
addhelp(NORMALIZED, "See help(8)"); 
addhelp(FOOLHARDY, "See help(8)");
{addhelp(ab_radkron,
   "ab_radkron(ab,xn,n): Recursion coefficients of 2n-point Radau-Kronrod "
   "formula.  If n==1 or n is too large, the largest possible n is used.")} 

{addhelp(vxw_vqe,
  "vxw_vqe(vqe): calculated stratified sequence of formulas. The result is"
  "a vector, each component of which is an xw.")}
{addhelp(integrate,
  "integrate('fun',xw): Integrate the function 'fun' by the quadrature formula xw")} 
{addhelp(stratified_integrate, "stratified_integrate(vxw): "
  "Integrate the function 'fun' by the stratified sequence of quadrature"
  "formulas vxw")} 
addhelp(qe_xw, "qe_xw(xw)");
addhelp(ab_dw, "ab_dw(dw)");
addhelp(ab_xw, "ab_xw(xw)");
addhelp(dw_ab, "dw_ab(ab)");
\\addhelp(xw_qe, "xw_qe(qe,{n})");
addhelp(xw_ab, "xw_ab(ab,{n})");
addhelp(fs_xw, "fs_xw(xw): transform to inverse factorial series");
addhelp(r_qe, "r_qe(qe,x): evaluate Stieltjes function at x");
addhelp(r_ab, "r_ab(ab,x): evaluate Stieltjes function at x");
addhelp(r_xw, "r_xw(xw,t): evaluate Stieltjes function at t");
addhelp(r_fs, "r_fs(xw,t): evaluate Stieltjes function at t");
addhelp(pu_qe, "pu_qe(qe,x): evaluate polynomials p_k(x), u_k(x)");
addhelp(qe_r, "qe_r(r): find qe from symbolic Stieltjes function r");
addhelp(stqd_symb, "stqd_symb(qe,{sig=0}): stationary qd algorithm with symbolic handling of zero divisors");
addhelp(m_qe, "m_qe(qe,QE): modified moments of qe with respect to system generated by QE");
addhelp(qe_m, "qe_m(nu,QE,{n=n0}): n pairs of two-term coefficients from modified moments; n0 is the largest possible n");
addhelp(drop, "drop(z,k): drop first k elements from vector z, or from each component of z if z is one of qe, ab or xw.  If k<0, drop last k elements.");
addhelp(take, "take(z,k): take first k elements from vector z; or k from the first and k-1 from the second if z is qe or ab.  If k<0, take last k elements.");
addhelp(reverse, "reverse(z): reverse vector z, or each component of z if z is qe, ab or xw.  If k<0, drop last k elements.")
addhelp(exactness, "exactness(qe,QE,{eps=eps0}): degree of exactness of qe as an approximation to QE.  eps0 is a precision-dependent tolerance.")
addhelp(gaps, "gaps(qe)")
addhelp(poles, "poles(qe)")
addhelp(weight, "weight(qe,x)") 
addhelp(xw_combine, "xw_combine(xw,XW,{eps=eps0},{g=g0}): combine quadrature formulas with relative importance g=[g1,g2]; nodes differing by less than eps are coalesced. eps0 is a precision-dependent tolerance; g0=[1/2,1/2].") 
addhelp(o_eval, "o_eval(c,ab,x): evaluate orthogonal expansion at x") 
addhelp(o_mulx, "o_mulx(c,ab): multiply orthogonal expansion by x") 
addhelp(o_dot, "o_eval(c1,c2,ab): dot product of two orthogonal expansions") 
{addhelp(ab_refinable, "ab_refinable(n,g): n recursion coefficients "
  "[a,b] for the refinable weight function with mask g.");}

print("  Novice users should type 'help()'.")
